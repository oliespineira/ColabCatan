from __future__ import annotations
from dataclasses import dataclass, field
from typing import Dict, List, Tuple, Callable, Optional, Iterable
import random
from collections import Counter, defaultdict

#Basic type aliases 
Resource = str          # e.g., "wood", "brick", "sheep", "wheat", "ore"
StructureKind = str     # "settlement" or "city"
PlayerID = str          # usually a string or player name/id

 
# PlayerView: represents each player visible info
@dataclass
class PlayerView:
    player_id: PlayerID
    name: str
    resources: Counter = field(default_factory=Counter)  # player’s resource cards

    def total_cards(self) -> int:
        """Return total count of resource cards."""
        return sum(self.resources.values())

    def add(self, res: Resource, n: int = 1) -> None:
        """Add n of a resource to player's hand."""
        if n > 0:
            self.resources[res] += n

    def remove(self, res: Resource, n: int = 1) -> bool:
        """Try to remove n of a resource. Returns True if successful."""
        if self.resources[res] >= n:
            self.resources[res] -= n
            if self.resources[res] == 0:
                del self.resources[res]
            return True
        return False

    def remove_random_cards(self, n: int) -> Counter:
        """Remove n random cards from the player (used for robber discard)."""
        removed = Counter()
        for _ in range(n):
            if not self.resources:
                break
            # create a list of all individual cards
            pool = [r for r, cnt in self.resources.items() for _ in range(cnt)]
            res = random.choice(pool)
            self.remove(res, 1)
            removed[res] += 1
        return removed


# TileView: represents a single hex tile on the board 
@dataclass(frozen=True)
class TileView:
    tile_id: int
    number: int                     # number token (2–12)
    resource: Optional[Resource]    # type of resource or None for desert
    vertices: Tuple[str, ...]       # surrounding vertex ids
    has_robber: bool = False        # whether robber is currently here


# vertex_owners maps vertex_id -> (player_id, "settlement"/"city")
VertexOwner = Tuple[Optional[PlayerID], Optional[StructureKind]]


# BoardSnapshot: simple summary of the current board 
@dataclass
class BoardSnapshot:
    tiles: Dict[int, TileView]              # all tiles on the board
    vertex_owners: Dict[str, VertexOwner]   # who owns which vertex
    robber_tile_id: Optional[int]           # where robber is currently placed


# Type hints for callback functions 
ChooseRobberTarget = Callable[[BoardSnapshot, PlayerID], int]
ChooseRobberVictim = Callable[[Iterable[PlayerView]], Optional[PlayerView]]
ChooseDiscard = Callable[[PlayerView, int], Counter]
ChooseStealResource = Callable[[PlayerView], Optional[Resource]]


# Default behavior iff no custom hooks are provided 
def default_choose_discard(player: PlayerView, n: int) -> Counter:
    """Default: player discards random cards."""
    return player.remove_random_cards(n)


def default_choose_victim(candidates: Iterable[PlayerView]) -> Optional[PlayerView]:
    """Default: pick random victim among adjacent players."""
    cands = [p for p in candidates if p.total_cards() > 0]
    return random.choice(cands) if cands else None


def default_choose_steal_resource(victim: PlayerView) -> Optional[Resource]:
    """Default: pick random resource card from victim."""
    if victim.total_cards() == 0:
        return None
    pool = [r for r, cnt in victim.resources.items() for _ in range(cnt)]
    return random.choice(pool) if pool else None


# Main Turn Engine 
class TurnEngine:
    def __init__(
        self,
        players: Dict[PlayerID, PlayerView],
        board: BoardSnapshot,
        choose_robber_target: ChooseRobberTarget,
        choose_robber_victim: ChooseRobberVictim = default_choose_victim,
        choose_discard: ChooseDiscard = default_choose_discard,
        choose_steal: ChooseStealResource = default_choose_steal_resource,
    ):
        """
        Initialize with all players, board, and callbacks.
        The callbacks allow UI or AI to make decisions.
        """
        self.players = players
        self.board = board
        self.choose_robber_target = choose_robber_target
        self.choose_robber_victim = choose_robber_victim
        self.choose_discard = choose_discard
        self.choose_steal = choose_steal

    #Dice rolling 
    @staticmethod
    def roll_dice() -> int:
        """Roll two six-sided dice and return the total (2–12)."""
        return random.randint(1, 6) + random.randint(1, 6)

    # Resource distribution 
    def distribute_resources(self, roll: int) -> Dict[PlayerID, Counter]:
        """
        Distribute resources to players after a dice roll (not 7).
        Settlements get 1 resource; cities get 2.
        """
        gained = defaultdict(Counter)

        # Check each tile to see iff it produces this roll
        for tile in self.board.tiles.values():
            if tile.number != roll or tile.has_robber or self.board.robber_tile_id == tile.tile_id:
                continue
            if tile.resource is None:
                continue

            # Give resources to owners of adjacent vertices
            for v in tile.vertices:
                owner, structure = self.board.vertex_owners.get(v, (None, None))
                if owner is None:
                    continue
                amount = 2 if structure == "city" else 1
                gained[owner][tile.resource] += amount

        # Apply resources to players’ inventories
        for pid, resources in gained.items():
            for res, n in resources.items():
                self.players[pid].add(res, n)

        return gained

    # Handle rolling a 7 
    def handle_seven(self, current_player_id: PlayerID) -> Dict[str, object]:
        """
        Handles all effects when a 7 is rolled:
        1. Players with >7 cards discard half (rounded down)
        2. Current player moves robber to new tile
        3. Current player steals 1 card from adjacent player
        """
        events = {"discards": {}, "robber": {}, "steal": {}}

        # Step 1: Discard phase
        for p in self.players.values():
            if p.total_cards() > 7:
                to_discard = p.total_cards() // 2
                removed = self.choose_discard(p, to_discard)
                # If player discarded too few, remove the rest randomly
                if sum(removed.values()) < to_discard:
                    removed += p.remove_random_cards(to_discard - sum(removed.values()))
                events["discards"][p.player_id] = dict(removed)

        # Step 2: Move robber
        target_tile_id = self.choose_robber_target(self.board, current_player_id)

        # Clear old robber
        if self.board.robber_tile_id is not None and self.board.robber_tile_id in self.board.tiles:
            old_tile = self.board.tiles[self.board.robber_tile_id]
            self.board.tiles[self.board.robber_tile_id] = TileView(
                old_tile.tile_id, old_tile.number, old_tile.resource, old_tile.vertices, has_robber=False
            )

        # Place robber on chosen tile
        new_tile = self.board.tiles[target_tile_id]
        self.board.tiles[target_tile_id] = TileView(
            new_tile.tile_id, new_tile.number, new_tile.resource, new_tile.vertices, has_robber=True
        )
        self.board.robber_tile_id = target_tile_id
        events["robber"] = {"moved_to": target_tile_id}

        # Step 3: Steal one card from adjacent player
        adjacent = set()
        for v in self.board.tiles[target_tile_id].vertices:
            owner, _ = self.board.vertex_owners.get(v, (None, None))
            if owner and owner != current_player_id:
                adjacent.add(owner)

        candidates = [self.players[pid] for pid in adjacent if self.players[pid].total_cards() > 0]
        victim = self.choose_robber_victim(candidates)

        if victim:
            # Pick resource to steal (random by default)
            res = self.choose_steal(victim) or random.choice(
                [r for r, cnt in victim.resources.items() for _ in range(cnt)]
            )
            victim.remove(res, 1)
            self.players[current_player_id].add(res, 1)
            events["steal"] = {"from": victim.player_id, "resource": res}
        else:
            events["steal"] = {"from": None, "resource": None}

        return events

    #Complete dice phase 
    def dice_phase(self, current_player_id: PlayerID, roll: Optional[int] = None) -> Dict[str, object]:
        """
        Run the dice roll part of a player's turn.
        If roll == 7 → handle robber logic.
        Else → distribute resources normally.
        """
        roll = self.roll_dice() if roll is None else roll
        if roll == 7:
            return {"roll": 7, **self.handle_seven(current_player_id)}
        else:
            gains = self.distribute_resources(roll)
            return {"roll": roll, "gains": {pid: dict(cnt) for pid, cnt in gains.items()}}


 
